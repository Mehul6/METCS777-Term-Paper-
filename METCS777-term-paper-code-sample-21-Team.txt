
-- Names: Tanvi Thopte, Mehul Bisht
-- Cleaning + analyzing ecommerce events in BigQuery

/*0) Create a clean, partitioned table from the raw events.
     PARTITION BY DATE(event_time) to speed up time-range scans.
     SAFE_CAST converts/validates types without failing the query.
     Filters out rows with NULL price, since price is central to revenue calcs. -*/

-- glassy-ripsaw-473223-u3 is project name with ecommerce_events_raw and later cleaned and has ecommerce_events_clean

CREATE OR REPLACE TABLE `glassy-ripsaw-473223-u3.ecommerce.events_clean`
PARTITION BY DATE(event_time)
AS
SELECT
  TIMESTAMP(event_time) AS event_time, -- normalize to TIMESTAMP
  event_type,  -- keeping as-is
  SAFE_CAST(product_id   AS STRING) AS product_id,   -- to string type
  SAFE_CAST(category_id  AS STRING) AS category_id,  -- to string type
  category_code,  -- may be NULL-used in group-bys
  brand,  -- may be NULL-pused in group-bys
  SAFE_CAST(price AS FLOAT64)AS price,        -- numeric price for math
  SAFE_CAST(user_id AS STRING) AS user_id,      -- user identifying
  SAFE_CAST(user_session AS STRING)AS user_session  -- session identifying
FROM `glassy-ripsaw-473223-u3.ecommerce.events_raw`
WHERE price IS NOT NULL;  -- remove rows without price

---EDA (Exploratory Data Analysis)

-- 0.1 Row count + time coverage (checking of table size and timeline)
SELECT
  COUNT(*) AS total_rows,
  MIN(event_time) AS first_event,
  MAX(event_time) AS last_event
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`;

-- 0.2 Missing data overview
SELECT
  SUM(CASE WHEN category_code IS NULL THEN 1 ELSE 0 END) AS null_category_code,
  SUM(CASE WHEN brand  IS NULL THEN 1 ELSE 0 END) AS null_brand,
  SUM(CASE WHEN price IS NULL THEN 1 ELSE 0 END) AS null_price  -- should be 0 by construction
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`;

-- 0.3 Cardinalities (uniques across main keys for sense of scale)
SELECT
  COUNT(DISTINCT product_id) AS unique_products,
  COUNT(DISTINCT user_id) AS unique_users,
  COUNT(DISTINCT user_session)  AS unique_sessions,
  COUNT(DISTINCT category_code) AS unique_categories,
  COUNT(DISTINCT brand) AS unique_brands
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`;

-- 0.4 Price stats (range, average, quartiles for distribution shape)
SELECT
  MIN(price) AS min_price,
  MAX(price) AS max_price,
  AVG(price) AS avg_price,
  APPROX_QUANTILES(price, 4) AS price_quartiles  -- min, Q1, median, Q3, max
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`;

-- 0.5 Monthly event distribution (volume + gross value per month)
SELECT
  FORMAT_DATE('%Y-%m', DATE(event_time)) AS month,
  COUNT(*) AS total_events,
  SUM(price) AS total_value
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
GROUP BY month
ORDER BY month;

-- PART B: Performance / Analyese
-- 1) Daily revenue trend with day-over-day change
--     Aggregates orders, revenue, avg ticket daily.
--    Uses LAG to compute day-over-day revenue delta.
WITH daily AS (
  SELECT
    DATE(event_time) AS day,
    COUNT(*) AS total_orders,
    SUM(price) AS total_revenue,
    AVG(price) AS avg_ticket
  FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
  GROUP BY day
)
SELECT
  day,
  total_orders,
  total_revenue,
  avg_ticket,
  total_revenue - LAG(total_revenue) OVER (ORDER BY day) AS revenue_change
FROM daily
ORDER BY day;

-- 2) Category into Brand aggregation (multi-dimensional performance view)
--    Filters out NULLs so results are cleaner.
--     Orders by revenue to surface top pairs.
SELECT
  category_code,
  brand,
  COUNT(*) AS total_orders,
  SUM(price) AS total_revenue,
  AVG(price) AS avg_price
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE brand IS NOT NULL AND category_code IS NOT NULL
GROUP BY category_code, brand
ORDER BY total_revenue DESC
LIMIT 1000;

-- 3) User-level monetization
--    Sessions = distinct sessions per user
--    Events = line-item or click-level counts.
--    total_spent, avg_spent = revenue view.
SELECT
  user_id,
  COUNT(DISTINCT user_session) AS sessions,
  COUNT(*) AS events,
  SUM(price)  AS total_spent,
  AVG(price)  AS avg_spent
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
GROUP BY user_id
ORDER BY total_spent DESC
LIMIT 1000;

-- 4) Session analytics (basket size/value)
--    unique_products = breadth of items in a basket.
--    items = total line count in session 
--    session_value = revenue per session.
SELECT
  user_session,
  COUNT(DISTINCT product_id) AS unique_products,
  COUNT(*) AS items,
  SUM(price) AS session_value
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
GROUP BY user_session
ORDER BY session_value DESC
LIMIT 1000;

-- 5) Trend + anomaly detection (7-day rolling z-score)
--    ma7 = 7-day moving average revenue.
--    sd7 = 7-day rolling std dev.
--    zscore flags deviations from short-term trend.
WITH daily AS (
  SELECT DATE(event_time) AS day, SUM(price) AS revenue
  FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
  GROUP BY day
),
stats AS (
  SELECT day,revenue,
    AVG(revenue) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7,
    STDDEV_POP(revenue) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS sd7
  FROM daily)

SELECT
  day, revenue, ma7, sd7,
  SAFE_DIVIDE(revenue - ma7, sd7) AS zscore
FROM stats
WHERE sd7 IS NOT NULL
ORDER BY day;

-- 6) Scalability experiment (compare scan size/latency by time window)
--    Same aggregation over 1 month, 3 months, and 7 months.
--    Measure performance externally (bytes processed, duration).

-- 6a: 1 month window
SELECT category_code, brand, SUM(price) AS revenue
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2019-11-01')
GROUP BY category_code, brand;

-- 6b: 3 month window
SELECT category_code, brand, SUM(price) AS revenue
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2020-01-01')
GROUP BY category_code, brand;

-- 6c: full 7 months window
SELECT category_code, brand, SUM(price) AS revenue
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2020-05-01')
GROUP BY category_code, brand;

-- 7) Top-K products by revenue (exact ranking)
SELECT product_id, SUM(price) AS revenue
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
GROUP BY product_id
ORDER BY revenue DESC
LIMIT 100;

-- 8) Brand-level price outliers (|z| > 3)
--     per-brand mean & stddev.
--    Join back to score each event’s price.
WITH brand_stats AS (
  SELECT brand, AVG(price) AS avg_price, STDDEV_POP(price) AS sd_price
  FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
  GROUP BY brand
)
SELECT
  e.brand, e.product_id, e.price, b.avg_price, b.sd_price,
  SAFE_DIVIDE(e.price - b.avg_price, b.sd_price) AS z
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean` e
JOIN brand_stats b USING (brand)
WHERE b.sd_price IS NOT NULL AND ABS(SAFE_DIVIDE(e.price - b.avg_price, b.sd_price)) > 3
ORDER BY z DESC
LIMIT 100;


/*Heavy queries repeated with explicit global time filter (2019-10 to 2020-04)*/

-- Category × Brand
SELECT
  category_code,
  brand,
  COUNT(*)   AS total_orders,
  SUM(price) AS total_revenue,
  AVG(price) AS avg_price
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2020-05-01')
  AND category_code IS NOT NULL AND brand IS NOT NULL
GROUP BY category_code, brand
ORDER BY total_revenue DESC
LIMIT 1000;

-- User-level large group-by
SELECT
  user_id,
  COUNT(DISTINCT user_session) AS sessions,
  COUNT(*)  AS events,
  SUM(price) AS total_spent,
  AVG(price)AS avg_spent
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2020-05-01')
GROUP BY user_id
ORDER BY total_spent DESC
LIMIT 1000;

-- Session analytics (very high cardinality)
SELECT
  user_session,
  COUNT(DISTINCT product_id) AS unique_products,
  COUNT(*)  AS items,
  SUM(price)  AS session_value
FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2020-05-01')
  AND user_session IS NOT NULL
GROUP BY user_session
ORDER BY session_value DESC
LIMIT 1000;

-- Rolling-window trend + anomalies (7-day z-score)
WITH daily AS (
  SELECT DATE(event_time) AS day, SUM(price) AS revenue
  FROM `glassy-ripsaw-473223-u3.ecommerce.events_clean`
  WHERE event_time >= TIMESTAMP('2019-10-01') AND event_time < TIMESTAMP('2020-05-01')
  GROUP BY day
)
SELECT
  day,
  revenue,
  AVG(revenue)  OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS ma7,
  STDDEV_POP(revenue) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS sd7,
  SAFE_DIVIDE(
    revenue - AVG(revenue) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW),
    NULLIF( STDDEV_POP(revenue) OVER (ORDER BY day ROWS BETWEEN 6 PRECEDING AND CURRENT ROW), 0)
  ) AS zscore
FROM daily
ORDER BY day;

